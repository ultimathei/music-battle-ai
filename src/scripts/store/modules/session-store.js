/**
 * Store module for the recorded session
 * including a list of musical patterns played by
 * user and the responses played by app
 *
 * A session is a list of patterns.
 * A pattern is essentially 4 bars played by either the user or the response of
 * the app (ai/robot) for the pattern.
 */
import { convertToPatternTime } from "../../utils/utils";
import { SESSION_MUTATION_ADD_NOTE_TO_CURRENT_PATTERN } from "../mutations";
import {
  SESSION_ACTION_GENERATE_RESPONSES,
  SESSION_ACTION_CLEAR_SESSION,
  SESSION_ACTION_PLAY_CURRENT_NOTES,
  SESSION_ACTION_CONFIRM_SEED,
  SESSION_ACTION_CLOSE_UNFINISHED_NOTES,
  SESSION_ACTION_FINISHED_MELODY,
  SESSION_ACTION_LOADING,
  SESSION_ACTION_SET_AIMELODIES,
  INSTRUMENT_ACTION_START_NOTE,
  INSTRUMENT_ACTION_END_NOTE,
  MODEL_ACTION_GENERATE_SIMILARS,
  CLOCK_ACTION_RESET,
  CLOCK_ACTION_RESET_PRECOUNT,
  CLOCK_ACTION_STARTSTOP,
  CLOCK_ACTION_STOP,
} from "../actions";
import {
  convertToMagentaSample,
  convertFromMagentaSequence,
} from "../../utils/utils";

const INSTRUMENT_STORE_LOC = "instrumentStore/";
const MODEL_STORE_LOC = "modelStore/";
const CLOCK_STORE_LOC = "mainClockStore/";

export default {
  namespaced: true,
  state: () => ({
    userTurn: true, // flags status of turn
    currentPattern: [], // alwyas stores the latest pattern
    session: [], // a list of alternating user/response patterns
    isSessionLoading: false, // flag status of session
    seedMelody: null, // the seed melody of the session
    quantizedSeedMelody: null,
    aiMelodyArray: [], // to store the melodies generated by the ai, based on seed
    userMelodyArray: [], // the user's attemps for each aiMelody
    prematureNotes: [], // this would be used to cache notes that are strated just before the pattern start
    currentMatchIndex: 0, // the index of current match in the game session
  }),

  getters: {
    session(state) {
      return state.session;
    },
    userTurn(state) {
      return state.userTurn;
    },
    currentPattern(state) {
      return state.currentPattern;
    },
    seedMelody(state) {
      return state.seedMelody;
    },
    userMelodyArray(state) {
      return state.userMelodyArray;
    },
    aiMelodyArray(state) {
      return state.aiMelodyArray;
    },
    isSessionLoading(state) {
      return state.isSessionLoading;
    },
  },

  actions: {
    // IDEA ///////
    // idea for VAE interpolate
    // 1. take user's input first
    //  1.a from_sequence = user input notes
    //  1.b determine scale eg. scale = 'CM'
    // 2. get a sample: to_sequence = model.sample(1, 1.0, [scale]) ?? how to sepcify scale?
    // 3. results = vae.interpolate([from_sequence, to_sequence], num_of_interppolation_steps, 1.0, [scale])
    //////////////////
    ////////

    // IDEA
    // for prematureNotes: if not userTurn and MIDI not receieved:
    // collect theese notes to an array with start value 0.
    // is end note message received for same pitch, remove from array
    // at the start of a new user pattern, push the content of this array to
    // the currentPattern array

    ///////
    /**
     * Playback of current pattern sound
     * @param {*} time
     */
    [SESSION_ACTION_PLAY_CURRENT_NOTES]({ state }, currentTime) {
      state.currentPattern.forEach((note) => {
        if (note.start >= 0 && note.start == currentTime) {
          // play sound for note
          this.dispatch(
            INSTRUMENT_STORE_LOC + INSTRUMENT_ACTION_START_NOTE,
            note.note
          );
        } else if (note.end && note.end == currentTime) {
          // stop sound for note
          this.dispatch(
            INSTRUMENT_STORE_LOC + INSTRUMENT_ACTION_END_NOTE,
            note.note
          );
        }
      });
    },

    // message recieved from clock at the end of each 4-bar cycle
    [SESSION_ACTION_FINISHED_MELODY]({ state, dispatch }) {
      // stop all notes, this prevents overflows
      // console.log(state.currentPattern);
      dispatch(SESSION_ACTION_CLOSE_UNFINISHED_NOTES);

      if (!state.seedMelody) {
        // change to modes
        // send stop clock message
        // console.log("at the end of seed melody, stop clock, display edit..");
        this.dispatch(CLOCK_STORE_LOC + CLOCK_ACTION_STOP);

        // if there were notes recorded to currentPattern
        if (
          state.currentPattern.length == 0 &&
          this.state.mode == "seed_recording"
        )
          this.commit("mutateMode", "initial");
      } else if (state.aiMelodyArray.length < 1 && state.userTurn) {
        // console.log("whole session finished, stop the clock..");
        this.dispatch(CLOCK_STORE_LOC + CLOCK_ACTION_STOP);
        this.commit("mutateMode", "scoring");
      } else {
        // console.log("still have melodies to play, move to next..");
        dispatch("moveToNextMelody");
      }
    },

    async [SESSION_ACTION_CONFIRM_SEED]({ state, dispatch }) {
      // state.isSessionLoading = true; // use this to display loader?
      // as confirmed make current pattern the seed
      state.seedMelody = state.currentPattern;
      state.isSessionLoading = true;

      // get ai melodies
      await this.dispatch(
        MODEL_STORE_LOC + MODEL_ACTION_GENERATE_SIMILARS,
        convertToMagentaSample(state.seedMelody, 120, 8)
      );
      state.isSessionLoading = false;

      dispatch("nextRobotMelody");

      // reset precount and start the battle
      this.dispatch(CLOCK_STORE_LOC + CLOCK_ACTION_RESET);
      this.dispatch(CLOCK_STORE_LOC + CLOCK_ACTION_RESET_PRECOUNT);
      this.dispatch(CLOCK_STORE_LOC + CLOCK_ACTION_STARTSTOP);
      this.commit("mutateMode", "battle");
    },

    [SESSION_ACTION_SET_AIMELODIES]({ state }, melodiesArray) {
      state.aiMelodyArray = melodiesArray;
    },

    [SESSION_ACTION_LOADING]({ state }) {
      state.isSessionLoading = true;
    },

    // make an action variable for this?
    moveToNextMelody({ state, dispatch }) {
      // move to next melody
      if (state.userTurn) {
        dispatch("nextRobotMelody");
      } else {
        dispatch("nextUserMelody");
      }
    },

    nextRobotMelody({ state, dispatch }) {
      // console.log("transitioning from USER to ROBOT turn..");
      // 1. push old current pattern to session
      const patternToArchive = {
        type: "user",
        pattern: [...state.currentPattern],
      };

      state.session.push(patternToArchive);
      state.userMelodyArray.push(patternToArchive);

      // 2. get the next element from the start of the ai array
      let melody = state.aiMelodyArray.shift();
      // console.log(melody);
      // 3. add it as the current pattern
      state.currentPattern = convertFromMagentaSequence(melody);
      // flip user turn boolean
      state.userTurn = false;
    },

    nextUserMelody({ state }) {
      // console.log("transitioning from ROBOT to USER turn..");
      // 1. push old current pattern to session
      const patternToArchive = {
        type: "robot",
        pattern: [...state.currentPattern],
      };

      state.session.push(patternToArchive);
      // state.  .push(patternToArchive);

      // clear current pattern - make it ready for user to play
      state.currentPattern = [];
      // flip user turn boolean
      state.userTurn = true;
    },

    // modified now -- not used now
    [SESSION_ACTION_GENERATE_RESPONSES]({ state, dispatch }) {
      // transitioning from user turn to response turn..
      if (state.userTurn) {
        // console.log("generate ai patterns here..");
        // dispatch(SESSION_ACTION_CLOSE_UNFINISHED_NOTES);
        // 1. push old current pattern to session
        const patternToArchive = {
          type: "user",
          pattern: [...state.currentPattern],
        };
        state.session.push(patternToArchive);

        // 2. response pattern becomes the new current pattern
        if (state.responseSequenceArray.length < 1) {
          // stop playback
          this.dispatch(CLOCK_STORE_LOC + CLOCK_ACTION_STARTSTOP);
          return;
        }

        let sample = state.responseSequenceArray.shift();
        // console.log(sample);

        state.currentPattern = convertFromMagentaSequence(sample);
      } else {
        // transitioning from response turn to user turn..
        // 1. push old current pattern to session
        const patternToArchive = {
          type: "robot",
          pattern: [...state.currentPattern],
        };
        state.session.push(patternToArchive);

        // clear current pattern - make it ready for user to play
        state.currentPattern = [];
      }
      // flip user turn boolean
      state.userTurn = !state.userTurn;
    },

    // clear/empty the current session
    [SESSION_ACTION_CLEAR_SESSION]({ state }) {
      state.seedMelody = null;
      state.currentPattern = [];
      state.aiMelodyArray = [];
      state.session = [];
      state.userTurn = true;
    },

    [SESSION_ACTION_CLOSE_UNFINISHED_NOTES]({ state, dispatch }) {
      state.currentPattern.forEach((note) => {
        // console.log(note);
        if (!note.end || note.end > 128) {
          note.end = 128;
          // send stop soound message here?
          dispatch("recordNoteChanges", {
            on_message: false,
            note: note.note,
            time: { bar: 4, demisemi: 32 },
          });
        }
        // test this!
        if (!note.start) {
          note.start = 0;
        }

        // stop playback of all notes
        this.dispatch(
          INSTRUMENT_STORE_LOC + INSTRUMENT_ACTION_END_NOTE,
          note.note
        );
      });
    },

    /**
     * Storing note MIDI messaged as they come in
     */
    recordNoteChanges({ commit }, payload) {
      let data = { note: payload.note };
      if (payload.on_message) data.start = convertToPatternTime(payload.time);
      else data.end = convertToPatternTime(payload.time);
      // send data here to store
      commit(SESSION_MUTATION_ADD_NOTE_TO_CURRENT_PATTERN, data);
    },

    quantizeSeedMelody({ state }) {
      // maybe store it in a different array, so we can revert?

      // quantize to 16th notes
      let newPattern = state.currentPattern.map((note) => {
        return {
          note: note.note,
          start: Math.floor(note.start / 4) * 4,
          end: Math.ceil(note.end / 4) * 4,
        };
      });

      for (let i = 0; i<newPattern.length-1; i++) {
        let thisNote = newPattern[i];
        let nextNote = newPattern[i+1];
        // if overlap with next
        if(thisNote.end > nextNote.start) {
          thisNote.end = nextNote.start;

          // let lengthOfTwo = nextNote.end - thisNote.start;
          // // devide proportionally if possible
          // let lengthOfThisNote = thisNote.end - thisNote.start;
          // let lengthOfNextNote = nextNote.end - nextNote.start;
          
          // thisNote.end = thisNote.start + Math.ceil((lengthOfTwo / lengthOfThisNote) / 4);
          // nextNote.start = thisNote.end;

          // if(nextNote.start == nextNote.end){
          //   nextNote.end+=3;
          // }
        }
        if(thisNote.start == thisNote.end) {
          thisNote.end +=3;
        }
      }

      state.currentPattern = newPattern;
    },
  },

  // basiacally setters
  // using the ES2015 computed property name feature
  mutations: {
    // add new incoming notes (either start or end msg) ONLY when in user turn
    [SESSION_MUTATION_ADD_NOTE_TO_CURRENT_PATTERN](state, data) {
      if (!state.userTurn) return; // safety check

      // its a start message push it straight to the pattern
      if (data.start) {
        state.currentPattern.push({
          ...data,
          start: Math.max(data.start - 1, 0),
        });
      } else if (data.end) {
        // else it's end message so
        // find the note that has no end yet (its start pair)
        state.currentPattern.forEach((n) => {
          if (n.note === data.note && !n.end) {
            n.end = data.end;
            return;
          }
        });
      }
    },
  },
};
